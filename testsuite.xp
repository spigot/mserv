#!/usr/bin/expect
#-*-sh-*-

# This expect script performs some basic testing of mserv.  It
# requires two user accounts to exist; "johan" with password "johan"
# and "root" with password "root".  "johan" should be a normal user
# and "root" a superuser.  It also requires at least one song in one
# album and an otherwise working configuration.
#
# This script must be run when mserv has just started, as it expects
# no history entries and nobody logged in to start with.  A successful
# run ends with mserv being shut down.
#
# A failed run ends either with an error message or that the script
# execution just hangs

# Hang if something unexpected happens
set timeout -1

# Log in as Johan and mess around
spawn telnet localhost 4444
set humanjohan $spawn_id
expect "USER"
send "user johan\n"
expect "PASS"
send "pass johan\n"
expect "Welcome johan"

# Log in as a computerized Johan and lurk
spawn telnet localhost 4444
set computerjohan $spawn_id
expect "USER"
expect "\n.\n"
send "user johan\n"
expect "PASS"
expect "\n.\n"
send "pass johan rtcomputer\n"
expect "202"
expect "Welcome johan"
expect "\n.\n"
expect -i $humanjohan "johan has connected"

send "history\n"
expect "412 There are no entries in the history"

# Default to operating on the human user
set spawn_id $humanjohan

send "who\n"
expect "The following people are online"
expect "johan"
expect "johan"

send "agdgdaagdgad\n"
expect "not understood"

# Test only bogus rating commands, root will test actual re-ratings
send "rate\n"
expect "Bad rate type"
send "rate neutral\n"
expect "Nothing playing"
send "rate 999999 neutral\n"
expect "No such album"
send "rate 1 999999 neutral\n"
expect "No such track"

send "ratings\n"
expect "Nothing playing"
send "ratings 1 1\n"
expect "Ratings of track"

send "history\n"
expect "no entries"

send "userinfo\n"
expect "User johan"
expect "Satisfaction:"
send "userinfo root\n"
expect "User root"
expect "Satisfaction:"

send "tracks\n"
expect "Nothing playing"
send "tracks 1\n"
expect "Tracks in album"

send "asearch kljhlkhufwiuytrqwerfskhuiwregf\n"
expect "No albums matching"

send "search kljhlkhufwiuytrqwerfskhuiwregf\n"
expect "No tracks matching"

send "status\n"
expect "Nothing currently playing"

send "stop\n"
expect "Nothing playing"

send "pause\n"
expect "Nothing playing"

send "top\n"
expect "Most likely to be played tracks"

send "albums\n"
expect "Albums available"

send "queue\n"
expect "no tracks in the queue"
send "queue 1 1\n"
expect "The following tracks have been added to the queue"
expect -i $computerjohan "=618\tjohan"
expect -i $computerjohan "=619\tjohan\t1\t1"

send "queue\n"
expect "The following tracks are in the queue"
send "unqueue 1 1\n"
expect "unqueued by johan"
expect -i $computerjohan "=627\tjohan\t1\t1"

send "next\n"
expect "Nothing playing"

send "volume\n"
expect "Volume is currently"

send "info\n"
expect "Nothing playing"
send "info 1\n"
expect "Album name"
send "info 1 1\n"
expect "Track name"

# Start playing and try some commands again
send "play\n"
expect "Playing"

send "status\n"
expect "Track name"
expect -re {Time playing: +([0-9]+):([0-9][0-9])[^0-9]}

if { $expect_out(1,string) > 0 || $expect_out(2,string) >= 2 } then {
	send_error "*** The status command says the just started song has played too long\n"
	exit 1
}

# What comes next is really the result of the "play" command, not
# "status".

# The reason we don't wait for the computer being notified about that
# a new song has started playing before we do "status" is that doing
# things this way has previously uncovered a bug.  We don't want that
# bug to re-appear in the future, so please don't change the order of
# "play", "status" and "expect -i $computerjohan" here.
expect -i $computerjohan "=622\trandom"

send "ratings\n"
expect "Ratings of track"

send "history\n"
expect "The following tracks were recently played"

send "tracks\n"
expect "Tracks in album"

send "pause\n"
expect "paused"
expect -i $computerjohan "=606\tjohan"

send "pause\n"
expect "Already paused"

send "play\n"
expect "resumed by johan"
expect -i $computerjohan "=605\tjohan"

send "next\n"
expect "Track skipped"
expect "Playing:"
expect -i $computerjohan "=629\tjohan"
expect -i $computerjohan "=622\trandom"

send "info\n"
expect "Track name"

send "play\n"
expect "Already playing"

send "stop\n"
expect "stopped"
expect -i $computerjohan "=623\tjohan"

send "quit\n"
expect {
	eof { send_error "*** Human logged out without a goodbye!!\n" ; exit 1 }
	"Goodbye"
}
expect -i $computerjohan "=601\tjohan"
wait

# Log johan back in so we can do the same thing all over, only this
# time it will be the computer client that does all the work and the
# human only verifies that it gets notified about what happens.
spawn telnet localhost 4444
set humanjohan $spawn_id
expect "USER"
send "user johan\n"
expect "PASS"
send "pass johan\n"
expect "Welcome johan"
expect -i $computerjohan "=600\tjohan"

# Default to operating on the computer user
set spawn_id $computerjohan

send "who\n"
expect "226 The following people are online"
expect "johan"
expect "johan"
expect "\n.\n"

send "agdgdaagdgad\n"
expect "500 Command not understood"

# Test only bogus rating commands, root will test actual re-ratings
send "rate\n"
expect "518 Bad rate type"
send "rate neutral\n"
expect "401 Nothing playing"
send "rate 999999 neutral\n"
expect "508 No such album"
send "rate 1 999999 neutral\n"
expect "509 No such track"

send "ratings\n"
expect "401 Nothing playing"
send "ratings 1 1\n"
expect "229 Ratings of track"
expect "\n.\n"

send "status\n"
expect "224 Nothing currently playing"
expect "\n.\n"

send "history\n"
expect "241 The following tracks were recently played"
expect "\n.\n"

send "userinfo\n"
expect "246 User johan"
expect "johan\tjohan\t"
expect "\n.\n"
send "userinfo root\n"
expect "246 User root"
expect "root\tjohan\t"
expect "\n.\n"

send "tracks\n"
expect "401 Nothing playing"
send "tracks 1\n"
expect "228 Tracks in album"
expect "\n.\n"

send "asearch kljhlkhufwiuytrqwerfskhuiwregf\n"
expect "538 No albums"

send "search kljhlkhufwiuytrqwerfskhuiwregf\n"
expect "520 No tracks"

send "stop\n"
expect "401 Nothing playing"

send "pause\n"
expect "401 Nothing playing"

send "top\n"
expect "234 Most likely to be played"
expect "\n.\n"

send "albums\n"
expect "227 Albums available"
expect "\n.\n"

send "queue\n"
expect "404 There are no tracks in the queue"
expect "\n.\n"
send "queue 1 1\n"
expect "247 The following tracks have been added to the queue"
expect "\n.\n"
expect -i $humanjohan "The following tracks have been added to the queue"

send "queue\n"
expect "225 The following tracks are in the queue"
expect "\n.\n"
send "unqueue 1 1\n"
expect "254 Track"
expect -i $humanjohan "unqueued by johan"

send "next\n"
expect "401 Nothing playing"

send "volume\n"
expect "235 Volume is currently"

send "info\n"
expect "401 Nothing playing"
expect "\n.\n"
send "info 1\n"
expect "245 Album 1"
expect "\n.\n"
send "info 1 1\n"
expect "246 Album 1, track 1"
expect "\n.\n"

# Start playing and try some commands again
send "play\n"
expect "230 Play commenced"
expect "\n.\n"
expect -i $humanjohan "Playing:"

send "status\n"
expect "222 Playing"
# Verify that the amount of time the current song has been playing is
# on the format M:SS, which is what MServClient expects.
expect -re {\t[0-9]+:[0-5][0-9]\t}
expect "\n.\n"

send "ratings\n"
expect "229 Ratings of track"
expect "\n.\n"

send "tracks\n"
expect "228 Tracks in album"
expect "\n.\n"

send "pause\n"
expect "232 Play paused"
expect -i $humanjohan "paused by johan"

send "pause\n"
expect "406 Already paused"

send "play\n"
expect "230 Play commenced"
expect "\n.\n"
expect -i $humanjohan "resumed by johan"

send "next\n"
expect "240 Moved to next track"
expect -i $humanjohan "Track skipped"
expect -i $humanjohan "Playing: "

send "info\n"
expect "246 Album"
expect "\n.\n"

send "play\n"
expect "402 Already playing"

send "stop\n"
expect "231 Play stopped"
expect "\n.\n"
expect -i $humanjohan "stopped by johan"

send "quit\n"
expect {
	eof { send_error "*** Root logged out without a goodbye!!\n" ; exit 1 }
	"220 Goodbye"
}
wait
expect -i $humanjohan "johan has disconnected"

# Log the computer johan back in so he can be kicked off by root
spawn telnet localhost 4444
set computerjohan $spawn_id
expect "USER"
expect "\n.\n"
send "user johan\n"
expect "PASS"
expect "\n.\n"
send "pass johan rtcomputer\n"
expect "202"
expect "Welcome johan"
expect "\n.\n"
expect -i $humanjohan "johan has connected"

# Log in as root for testing root-only commands
spawn telnet localhost 4444
set humanroot $spawn_id
expect "USER"
send "user root\n"
expect "PASS"
send "pass root\n"
expect "Welcome root"
expect -i $humanjohan "root has connected"
expect -i $computerjohan "=600\troot"

# Verify that both Johans are still logged in
send "who\n"
expect "johan"
expect "johan"

send "kick johan\n"
expect "User johan has disconnected"

# Verify that the Johans actually disappeared
send "who\n"
expect "1 connected, 1 total"

# Verify that the human Johan got notified
set spawn_id $humanjohan
expect {
	eof { send_error "*** Human kicked without notification!!\n" ; exit 1 }
	"You have been kicked off"
}
wait

# Verify that the computer Johan gets notified
set spawn_id $computerjohan
expect {
	eof { send_error "*** Computer kicked without notification!!\n" ; exit 1 }
	"=526 You have been kicked off"
}
wait

# Benchmark the "queue" command, and make sure it doesn't take more
# than 100ms per invocation.
set spawn_id $humanroot
set t0 [clock clicks -milliseconds]
for {set x 0} {$x < 10} {incr x} {
    send "queue\n"
    expect "There are no tracks in the queue"
}
set t1 [clock clicks -milliseconds]
set timePerCallMs [ expr ($t1 - $t0) / 10.0 ]
send_user "The queue command takes $timePerCallMs ms per call\n"

if { $timePerCallMs >= 100 } {
	send_error "*** The queue command is too slow ($timePerCallMs ms per call)\n"
	exit 1
}

# Log in as a computerized root
spawn telnet localhost 4444
set computerroot $spawn_id
expect "USER"
expect "\n.\n"
send "user root\n"
expect "PASS"
expect "\n.\n"
send "pass root rtcomputer\n"
expect "202"
expect "Welcome root"
expect "\n.\n"
expect -i $humanroot "root has connected"

# Back to the human root
set spawn_id $humanroot

# Test ratings.  Better do this as root so we don't mess up Johan's
# ratings...
send "rate 1 1 awful\n"
expect "The track 1/1 has been rated AWFUL by root"
expect -i $computerroot "=614"
expect -i $computerroot "AWFUL"
send "rate 1 1 bad\n"
expect "The track 1/1 has been rated BAD by root"
expect -i $computerroot "=614"
expect -i $computerroot "BAD"
send "rate 1 1 good\n"
expect "The track 1/1 has been rated GOOD by root"
expect -i $computerroot "=614"
expect -i $computerroot "GOOD"
send "rate 1 1 superb\n"
expect "The track 1/1 has been rated SUPERB by root"
expect -i $computerroot "=614"
expect -i $computerroot "SUPERB"
send "rate 1 1 neutral\n"
expect "The track 1/1 has been rated NEUTRAL by root"
expect -i $computerroot "=614"
expect -i $computerroot "NEUTRAL"

send "ratings 1 1\n"
expect "root"
expect "NEUTRAL"

send "info 1 1\n"
expect "NEUTRAL"

send "play\n"
expect "Playing"
expect -i $computerroot "=622\trandom"

send "rate neutral\n"
expect "This track has been rated NEUTRAL by root"
# Note that the rtcomputer rating notification differs between "track
# foo has been rated" (=614) and "this track has been rated" (=615).
expect -i $computerroot "=615"
expect -i $computerroot "NEUTRAL"

send "ratings\n"
expect "root"
expect "NEUTRAL"

send "info\n"
expect "NEUTRAL"

send "stop\n"
expect "stopped"
expect -i $computerroot "=623\troot"

# Let the computer root rate stuff and verify that the human gets
# notified.
set spawn_id $computerroot

send "rate 1 1 awful\n"
expect "270"
expect "root"
expect "AWFUL"
expect -i $humanroot "The track 1/1 has been rated AWFUL by root"
send "rate 1 1 bad\n"
expect "270"
expect "root"
expect "BAD"
expect -i $humanroot "The track 1/1 has been rated BAD by root"
send "rate 1 1 good\n"
expect "270"
expect "root"
expect "GOOD"
expect -i $humanroot "The track 1/1 has been rated GOOD by root"
send "rate 1 1 superb\n"
expect "270"
expect "root"
expect "SUPERB"
expect -i $humanroot "The track 1/1 has been rated SUPERB by root"
send "rate 1 1 neutral\n"
expect "270"
expect "root"
expect "NEUTRAL"
expect -i $humanroot "The track 1/1 has been rated NEUTRAL by root"

send "ratings 1 1\n"
expect "229 Ratings of track"
expect "root\tNEUTRAL"
expect "\n.\n"

send "info 1 1\n"
expect "246 Album 1, track 1"
expect "NEUTRAL"
expect "\n.\n"

send "play\n"
expect "230 Play commenced"
expect "\n.\n"
expect -i $humanroot "Playing:"

send "rate neutral\n"
expect "270 Rated"
expect "root"
expect "NEUTRAL"
expect -i $humanroot "This track has been rated NEUTRAL by root"

send "ratings\n"
expect "229 Ratings of track"
expect "root\tNEUTRAL"
expect "\n.\n"

send "info\n"
expect "246 Album"
expect "NEUTRAL"
expect "\n.\n"

send "stop\n"
expect "231 Play stopped"
expect "\n.\n"
expect -i $humanroot "stopped by root"

# Let the human client shut down
set spawn_id $humanroot

send "shutdown\n"
expect {
	eof { send_error "*** MServ shutdown without saying anything!!\n" ; exit 1 }
	"shutdown by root"
}
wait

set spawn_id $computerroot
expect {
	eof { send_error "*** MServ shutdown without notifying computer users!!\n" ; exit 1 }
	"=633\troot"
}
wait
